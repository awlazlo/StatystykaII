---
title: "Analiza danych z CNK z maja 2012"
author: "Przemys³aw Dycha, Magda Sobiczewska, Krzysztof Smutek, Piotr Weremczuk"
date: "27 kwiecieñ 2016"
output: 
 html_document:
   toc: TRUE
---
#Faza I
## Wprowadzenie
Na samym pocz¹tku chcemy zbadaæ podstawowe statystyki dotycz¹ce eksponatów:
- liczba odwiedzaj¹cych w poszczególnych dniach tygodnia
- liczba odwiedzaj¹cych w zale¿noœci od godziny odwiedzin
- czas spêdzony na interakcje z eksponatem
- liczba odwiedzin pojedynczych stacji
- œredni czas spêdzony na danej stacji


## Obróbka danych i metody pracy
W poni¿szej analizie organiczyliœmy siê do danych z maja. Z powodu ograniczonych mo¿liwoœci obliczeniowych. Wyrzuciliœmy równie¿ u¿ytkowników oznaczonych -1 oraz inne rekordy zapisane z b³êdem lub bez niektórych wartoœci. Pozbyliœmy siê równie¿ tych, które wydawa³y nam siê w jakimœ sensie b³êdne, na przyk³ad odwiedzaj¹cych, którzy spêdzili na poszczególnych eksponatach wiêcej ni¿ godzinê.
Do otrzymania statystyk u¿yliœmy wbudowanych narzêdzi R oraz biblioteki sqldf i zapytañ w jêzyku SQL.

## Otrzymane wyniki

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
library(plyr)
library(lubridate)
library(ggplot2)
library(sqldf)
library(cluster)
library(ggrepel)
library(MASS)
library(vegan)
library(reshape2)
library(arulesViz)
library(arules)
library(mclust)
library(RColorBrewer)
library(pheatmap)
library(stringi)
load("maj.rda")

###################################### OBRÓBKA DANYCH ######################################

###czas spedzony przez k1zdego odwiedzaj1cego na ka??dej maszynie
time <- sqldf('SELECT station, visitor, MAX(date) - MIN(date) as time FROM a GROUP BY station, visitor')
time = time[-1,]
time$timenum = as.numeric(time[,3])
time = time[time$timenum < 3600,]

### pik w okolicach 100s w time
pik100<-time[time$timenum>95,]
pik100<-pik100[pik100$timenum<105,]
pik100<-sqldf('SELECT station, count(*) as liczba FROM pik100 GROUP BY station ORDER BY liczba DESC')

### Statystkyki maszyn : stacje, oredni czas dla danej stacji, liczba odwiedzaj1cych dan1 stacje
machineStatistics <- sqldf('SELECT station, MEDIAN(time) as mediantime, count(*) as numberOfVisitors FROM time GROUP BY station')


### najpopularniejsze maszyny: rózne stacje, liczba wizyt stacji, liczba stacji/ liczbe wizyt - orednia liczba odwiedzin stacji przez wizytora
most_famous_machine<-sqldf('SELECT DISTINCT station, COUNT(station)/2 as numberofvisits, COUNT(station)/(2*COUNT(DISTINCT visitor)) as medianvisitspervisitor FROM a GROUP BY station ORDER BY numberofvisits')
most_famous_machine = most_famous_machine[-1,]


###statystyki maszyn zebrane razem
machinestat<-sqldf('SELECT machineStatistics.station, machineStatistics.numberofVisitors,   most_famous_machine.numberofvisits, most_famous_machine.medianvisitspervisitor, machineStatistics.mediantime FROM machineStatistics INNER JOIN most_famous_machine ON machineStatistics.station=most_famous_machine.station')
machinestat[,4]=as.numeric(machinestat[,4])
machinestat$median_number_of_visitsper_day = machinestat$numberofvisits/27


###statystyki dniowe
time_per_day = sqldf('SELECT station, visitor, MAX(date) - MIN(date) as time, dayOfWeek, dayOfWeekNumber FROM a GROUP BY station, visitor, dayOfWeekNumber')
time_per_day = time_per_day[time_per_day$time < 3600, ]
time_per_day = time_per_day[-1,]

machineStatisticsWeekday <- sqldf('SELECT station, dayOfWeek, dayOfWeekNumber, AVG(time) as median_time, count(*) as numberOfVisitors FROM time_per_day GROUP BY station, dayOfWeekNumber')

weekdayStatistics = sqldf('SELECT dayOfWeek, dayOfWeekNumber, AVG(median_time) as average_time_per_day, sum(numberOfVisitors) as numberOfVisitorsPerDay FROM machineStatisticsWeekday GROUP BY dayOfWeekNumber')

weekdayStatistics[,4] = weekdayStatistics[,4]/c(4,5,5,5,4,4,4)


###statystyki godzinowe
time_per_day_and_hour = sqldf('SELECT station, visitor, MAX(date) - MIN(date) as time, dayOfWeek, dayOfWeekNumber, hour FROM a GROUP BY station, visitor, dayOfWeekNumber, hour')
time_per_day_and_hour = time_per_day_and_hour[-1,]

machineStatisticsWeekdayHour <- sqldf('SELECT station, dayOfWeek, dayOfWeekNumber, hour, AVG(time) as median_time, count(*) as numberOfVisitors FROM time_per_day_and_hour GROUP BY station, dayOfWeekNumber, hour')

weekdayHourStatistics = sqldf('SELECT dayOfWeek, dayOfWeekNumber, hour, AVG(median_time) as average_time_per_day_hour, sum(numberOfVisitors) as numberOfVisitors FROM machineStatisticsWeekdayHour GROUP BY dayOfWeekNumber, hour')

hourStatistics = sqldf('SELECT hour, AVG(average_time_per_day_hour) as average_time_per_hour, sum(numberOfVisitors) as numberOfVisitorsPerHour FROM weekdayHourStatistics GROUP BY hour')
hourStatistics$hour = as.numeric(hourStatistics$hour)
hourStatistics = hourStatistics[hourStatistics$hour %in% c(8,9,10,11,12,13,14,15,16,17,18,19),]
hourStatistics[,3] = hourStatistics[,3]/replicate(12, 27)


```

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
machinestat_cnk_group <-machinestat
#Klastry tematyczne cnk
machinestat_cnk_group$strefa[c(9,11,26,30:35,40:49,53:56,59)]<-2
machinestat_cnk_group$strefa[c(15,20:25,58)]<-4
machinestat_cnk_group$strefa[c(28:29,36:39,57)]<-3
machinestat_cnk_group$strefa[c(1:8,10,12:14,16:19,51:52)]<-1

#Wywalanie pustych i zamiana na typ factor do wykresu
machinestat_cnk_group<-machinestat_cnk_group[!is.na(machinestat_cnk_group$strefa),]
machinestat_cnk_group$strefa<-as.factor(machinestat_cnk_group$strefa)
```

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
###################################### WYKRESY ######################################

ggplot(weekdayStatistics, aes(dayOfWeek, numberOfVisitorsPerDay, fill=dayOfWeekNumber)) + geom_bar(stat="identity") + scale_y_continuous(breaks=seq(0,6000,500)) + ggtitle("Œrednia liczba odwiedzaj¹cych w danym dniu") + xlab(" ") + ylab(" ") + xlim(labels=c("poniedzia³ek", "wtorek", "œroda", "czwartek", "pi¹tek", "sobota", "niedziela")) + theme_minimal(base_size = 15) + theme(legend.position="none")


```

Zauwa¿amy, ¿e w poniedzia³ek  liczba odwiedzj¹cych jest bliska 0. Wynika to z faktu, ¿e CNK w tym dniu jest zamkniête. Pomimo tego mo¿na zauwa¿yæ znikome interakcje, gdy¿ s¹ wykonywane prace konserwacyjne na eksponatach. Ponadto liczba odwiedzaj¹cych w poszczególne dni jest zbli¿ona. Na mniejsz¹ liczbê we wtorek od pozosta³ych dni mia³ najprawdopodobniej wp³yw 1 maja, który w 2012 roku wypada³ w³aœnie we wtorek. Warto równie¿ zauwa¿yæ, ¿e w pi¹tki i soboty odwiedzaj¹cych jest œrednio nieco wiêcej w porównaniu do innych dni. Zapewne wynika to z faktu, i¿ s¹ to pierwsze dni weekendu.

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
ggplot(hourStatistics, aes(hour, numberOfVisitorsPerHour, color=1)) + geom_line(size=2) + xlab("Godzina") + ylab(" ") + ggtitle("Œrednia liczba odwiedzaj¹cych w ci¹gu dnia") + scale_x_continuous(breaks=c(8:19)) + theme_minimal(base_size=15) + scale_y_continuous(breaks=seq(0, 1500, 150)) + theme(legend.position = "none")


```

Zauwa¿amy, ¿e najwiêksza liczba odwiedzaj¹cych centrum jest w godzinach 12-16. W póŸniejszych i wczeœniejszych godzinach aktywnoœæ jest du¿o mniejsza. Mo¿e byæ to przydatna informacja dla osób, które chc¹ spokojnie zwiedziæ Centrum. 

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
ggplot(data=time,aes(x=timenum, color=1)) + geom_bar() +  scale_x_continuous(limits=c(0,500), breaks=seq(0,500,50)) + xlab("Czas w [s]") + ylab("Liczba odwiedzaj¹cych") + ggtitle("Czas spedzony przy maszynie przez u¿ytkownika") + theme_minimal(base_size = 15) + scale_y_continuous(breaks=seq(0,3000,250)) + theme(legend.position="none")


```

Rozk³ad czasu spêdzonego przy maszynie wydaje siê byæ zbli¿ony do rozk³adu gamma. Widaæ jednak, ¿e w okolicach 100 sekund nastêpuje znaczny skok liczby odwiedzaj¹cych. Zaintrygowani tym faktem zbadaliœmy, przy których maszynach odwiedzaj¹cy spêdzali miêdzy 95, a 105 sekund. Poni¿sza tabelka pokazuje najczêœciej pojawiaj¹ce siê przypadki.

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
head(pik100)
```

Mo¿na zauwa¿yæ, ¿e za tê nieregularnoœæ w rozk³adzie czasu spêdzonego przy maszynie odpowiada stanowisko Otwartoœæ na doœwiadczenie - cnk17. Zapewne skorzystanie z tej maszyny polega na przejœciu przez pewien proses, który zajmuje oko³o 100 sekund.

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
ggplot(data = machinestat_cnk_group, aes(x=station, y=numberOfVisitors, label=station, fill=strefa)) + geom_bar(stat="identity") + theme_minimal(base_size=15) + ggtitle("Liczba odwiedzeñ poszczególnych stacji") + ylab(" ") + geom_text(angle=90, hjust=1.1, vjust=0.3) + xlab(" ")  + scale_x_discrete(breaks=replicate(59, " "))



```

Zauwa¿amy, ¿e najbardziej odwiedzan¹ stacj¹ by³o Wejœcie do sali strachów - cnk19a oraz Wyjœcie z sali strachów - cnk19b (jest to zapewne jeden eksponat rozbijaj¹cy moment wejœcia i wyjœcia na osobne eksponaty). Ciekawe jest, ¿e liczba przejœæ przez Wejœcie do sali strachów jest prawie dwukrotnie wiêksza od liczby przejœæ przez Wyjœcie z sali strachów, co mo¿e sugerowaæ, ¿e wielu odwiedzaj¹cych ze strachu rezygnowa³o z przejœcia ca³ej sali. 
Innymi czêsto odwiedzanymi eksponatami s¹ Pow¹chaj mnie - cnk16, Mózg podczas pracy - cnk02 oraz Kim jesteœ - cnk18. Najmniej odwiedzanym eksponatem by³ Robot portrecista - cnk29a, dla którego niska liczba odwiedzaj¹cych spowodowana by³a zapewne d³ugim czasem spêdzanym przy eksponacie (patrz nastêpny wykres).

Ponadto dokonaliœmy podzia³u na stacje tematyczne cnk w sposób nastêpuj¹cy

- Strefa 1: JA
- Strefa 2: JA - MY - ONI
- Strefa 3: JA - ŒWIAT
- Strefa 4: JA - TY

Mo¿na zauwa¿yæ, ¿e zdecydowanie najwiêcej odwiedzin by³o w grupie JA. Wiêkszoœæ maszyn z tej grupy przekracza liczbê 5000 odwiedzeñ czego nie mo¿na powiedzieæ o innych grupach.

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
ggplot(data = machinestat_cnk_group, aes(x=station, y=mediantime, label=station, fill=strefa)) + geom_bar(stat="identity") + theme_minimal(base_size=15) + ggtitle("Œredni czas spedzony przy stacji") + ylab("Czas w [s]") + scale_y_continuous(breaks=seq(0,350,25)) + geom_text(angle=90, hjust=1.1, vjust=0.3) + xlab(" ") + scale_x_discrete(breaks=replicate(59, " ")) 

```

Tak jak pisaliœmy wczeœniej stacja Robot portrecista - cnk29a mia³a najwiêkszy czas spêdzany na eksponacie. Niewielka liczba odwiedzaj¹cych wynika z tego, ¿e jest ona bardzo czêsto zajêta. Byæ mo¿e warto by³oby utworzyæ nowy eksponat o podobnej charakterystyce.
Warto te¿ zwróciæ uwagê na stacjê Otwartoœæ na doœwiadczenie - cnk17, przy której rzeczywiœcie spêdzano œrednio oko³o 100 sekund co potwierdza nasze wczeœniejsze obserwacje.
Porównuj¹c oba powy¿sze wykresy mo¿na pokusiæ siê o wstêpne wybranie najmniej popularnych maszyn. Bêd¹ to te, dla których liczba odwiedzeñ jest ma³a jak i œredni czas spêdzony przy maszynie jest niski.

##Podsumowanie fazy I

Zauwa¿yliœmy, ¿e czasy interakcji z eksponatami s¹ w wiêkszoœci przypadków krótkie. W poszczególne dni tygodnia œrednia liczba odwiedzin jest podobna. Natomiast liczba odwiedzin Centrum jest najwy¿sza we wczesnych godzinach popo³udniowych.

Uda³o nam siê zbadaæ niektóre statystyki dotycz¹ce maszyn i dziêki temu wy³apaliœmy charakterystyczne stacje. Stworzyliœmy wstêpn¹ ocenê popularnoœci eksponatów.

# Faza II i III - analiza segmentów

## Wprowadzenie

W drugim etapie postaramy siê zbadaæ, czy dane dziel¹ siê na jakieœ charakterystyczne podgrupy.

Postaramy siê odpowiedzieæ na nastêpuj¹ce pytania:

- Czy istnieje jakiœ charakterystyczny podzia³ stacji ze wzglêdu na liczbê odwiedzin i œredni czas interakcji ?
- Jak wygl¹da zale¿noœæ miêdzy liczb¹ interakcji u¿ytkownika, a czasem spêdzonym na stacjach ?
- Jak wygl¹da podzia³ ze wzglêdu na liczbe odwiedzonych stacji i czas spêdzony na stacjach ?
- Czy mo¿na wyodrêbniæ charakterystyczne grupy zwiedzaj¹cych i stacji ?
 - Wreszcie, jakie s¹ zwi¹zki otrzymanych w ten sposób klastrów z podzia³em na strefy ?
 

## Uzyskane rezulaty

### Œredni czas, a liczba odwiedzin


Zastosowane metody:

W zwi¹zku z du¿¹ liczb¹ danych, odwiedzaj¹cy zostali podzieleni na podstawie algorytmu kmeans. Ograniczenia pamiêciowe nie pozwoli³y na policzenie potrzebnych odleg³oœci w inny sposób. Dokonaliœmy równie¿ podzia³u na sesje, który wyró¿nia odwiedzaj¹cego powracaj¹cego do eksponatu po pewnym czasie.

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}

#######################################NumberofVisitors-numberofvisits#################
machinestat$numberOfVisitors_norm<-scale(sqrt(machinestat$numberOfVisitors))
machinestat$numberofvisits_norm <-scale(sqrt(machinestat$numberofvisits))
 
machinestat$mediantime_norm<-scale(sqrt(machinestat$mediantime))

dist_median_time <- dist(machinestat[,c("numberOfVisitors_norm", "mediantime_norm")],method="manhattan")
dist_median_time_group<-pam(dist_median_time,k=3)
machinestat$median_time_group<-factor(dist_median_time_group$clustering)
centra_median_time<-machinestat[dist_median_time_group$id.med,]

ggplot(machinestat,aes(x=mediantime,y=numberOfVisitors,label=station,color=median_time_group))+geom_point()+geom_text_repel()+guides(color=guide_legend(title="Klastry")) + labs(x="Œredni czas spêdzony przy stacji w [s]", y="Liczba odwiedzeñ stacji")

```


Na tym  wykresie widaæ podzia³ stacji na trzy grupy w zale¿noœci od czasu oraz liczby odwiedzin. Liczba grup jest dobrana eksperymentalnie. Wiêksza liczba grup nie wnosi³a wiele do naszego podzia³u.
Pierwsza grupa charakteryzuje siê du¿¹ liczb¹ odwiedzin i krótkim czasem interakcji. W drugiej grupie znajduj¹ siê eksponaty, dla których œredni czas interakcji jest d³ugi, natomiast liczba odwiedzin ma³a. W ostatniej grupie znalaz³y siê ma³o popularne eksponaty dla których mamy niewielk¹ liczbê odwiedzin oraz krótki czas interakcji.
Potwierdzaj¹ to: tabelka z centrami grup i boxploty.

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
(centra_median_time[,c('station','numberOfVisitors','mediantime')] )

ggplot(machinestat,aes(mediantime,numberOfVisitors,colour=median_time_group))+geom_boxplot() +theme(legend.position="none") + ggtitle("Boxploty uzyskanych grup") +xlab("Œredni czas spêdzony przy stacji w [s]")+ylab("Liczba odwiedzeñ stacji") 
```

Przywo³uj¹c wykres z podzia³ami tematycznymi zauwa¿amy, ¿e grupê czerwon¹ (krótki czas, du¿a liczba odwiedzin) tworz¹ przede wszystkim eksponaty z kategorii JA. Potwierdza to zauwa¿one na wczeœniejszych wykresach zale¿noœci.

### Podzia³ ze wzglêdu na liczbê odwiedzonych stacji


```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
   
maj <-a
maj=maj[!maj$scene == "<Scene:Splash sceneId=Splash>", ]
maj=maj[!maj$scene == "<Scene:SecondSplash sceneId=Splash>",]

maj = maj[order(maj$station, maj$date, maj$visitor), ]
maj$visitor=as.numeric(maj$visitor)
maj$session <- cumsum(c(TRUE,as.logical(diff(maj$visitor))))
maj <-maj[!is.na(maj$station),]


```


Na samym pocz¹tku utworzyliœmy macierz w której zawarte s¹ informacje dotycz¹ce odwiedzaj¹cego. Dok³adniej:

- liczba wejœæ na danej stacji przez odwiedzaj¹cego
- ³¹czna liczba czynnoœci na wszystkich eksponatach
- œredni czas spêdzony na wszystkich odwiedzonych stacjach 
- liczba odwiedzonych stacji

Korzystaj¹c z tej charakteryzacji dokonaliœmy dwóch podzia³ów: 
zale¿noœci czasu spêdzonego od liczby interakcji oraz liczby odwiedzonych stacji w zale¿noœci od œredniego czasu spêdzonego na stacji. 
Poni¿ej przedstawiamy fragment macierzy oraz uzyskane rezultaty:



```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}

#Odwiedziny eksponatow
odwiedziny <- sqldf('SELECT station, visitor, session, dayOfWeekNumber, MAX(date) - MIN(date) as time FROM maj GROUP BY station, visitor, session, dayOfWeekNumber')

# Sredni czas odwiedzajacego na eksponacie
srczasodwiedzin <- sqldf('SELECT station, visitor, AVG(time) as srczas, COUNT(station) as sesje FROM odwiedziny GROUP BY station, visitor')

## Sredni czas na odwiedzajacego
srczasodwiedzajacego <- sqldf('SELECT visitor, AVG(srczas) as sredniczas, SUM(sesje) as liczbastacji FROM srczasodwiedzin   GROUP BY visitor')


#interakcje ze wzglêdu na eksponaty i wizytorów. Liczymy tylko liczby wejœæ
interakcjenaeksponacie = sqldf('SELECT station, visitor, COUNT(*) as liczba FROM maj WHERE type = "Entering" GROUP BY station, visitor');

#interakcje ze wzgglêdu na odwiedzaj¹cych
interakcjenawizyte = sqldf('SELECT visitor, SUM(liczba) as liczbainterakcji FROM interakcjenaeksponacie GROUP BY visitor');

#Tworzy tabelê z liczbami interakcji dla odwiedzaj¹cego
liczbainterakcji_tab=dcast(interakcjenaeksponacie, visitor ~ station, value.var = "liczba", fill = 0)


## wywalam z pustymi enteringami
srczasodwiedzajacego<-srczasodwiedzajacego[c(-27287,-36285),]



#Utworzona macierz klastrowania pobieraj¹c odpowiednie kolumny z #wczeœniejszych tabel

macierzklastrowania= liczbainterakcji_tab
macierzklastrowania$liczbainterakcji=interakcjenawizyte$liczbainterakcji
macierzklastrowania$sredniczas= srczasodwiedzajacego$sredniczas
macierzklastrowania$liczbastacji = srczasodwiedzajacego$liczbastacji

head(macierzklastrowania[,c(1:2,59:63)])
kMeans <- kmeans(scale(macierzklastrowania[,-1]), 3)


ggplot(macierzklastrowania, aes(x=liczbainterakcji, y=sredniczas, color=as.character(kMeans$cluster))) + geom_point(shape=1) + scale_x_continuous(limits=c(0, 200)) + scale_y_continuous(limits=c(0, 1000)) + labs(x="Liczba interakcji", y="Œredni czas spêdzony przy eksponatach w [s]") + guides(color=guide_legend(title="Klastry"))+ggtitle('Liczba interakcji w zale¿noœci od czasu')
```

Podzia³ na trzy grupy zosta³ ustalony w sposób eksperymentalny, wiêksza liczba klastrów nie dawa³a dodatkowych wniosków. Jak mo¿na by³o siê spodziewaæ, du¿a liczba interakcji wi¹¿e siê z krótkim œrednim czasem poœwiêconym eksponatowi. Mo¿na równie¿ zauwa¿yæ, ¿e czynnikiem rozró¿niaj¹cym odwiedzaj¹cych jest w du¿ej mierze liczba interakcji. Stosunkowo niewielka liczba odwiedzaj¹cych plasuje siê powy¿ej œredniego czasu równego 250 sekund.  W ostatniej grupie znajduj¹ siê osoby charakteryzuj¹ce siê d³ugim czasem interakcji i ich niewielk¹ liczb¹.

```{r echo= FALSE, cache=FALSE, message=FALSE, warning=FALSE}

klastryodwiedzajacych <- macierzklastrowania
# dorzucamy klastry  z podzia³ki liczba interakcji w zaleznosci od czasu
klastryodwiedzajacych$cluster <- kMeans$cluster

klastryodwiedzajacych2 <- klastryodwiedzajacych[,c('visitor','cluster')]

#podzial na liczbe interakcji odwiedzajacego na kazdej stacji
sesje = sqldf('SELECT station, visitor, count(*) as count FROM maj WHERE type = "Entering" GROUP BY station, visitor');
sesje=merge(sesje,klastryodwiedzajacych2)


interakcje<- sqldf('select station, cluster , count from sesje GROUP BY station, cluster')
interakcje$cluster <-factor(interakcje$cluster)


ggplot(data=interakcje, aes(x=station, y=count, fill=cluster)) + geom_bar(position ="fill",stat="identity")+theme(axis.text.x=element_text(angle=70)) + labs(x="stacje", y="Proporcje interakcji u¿ytkowników")



```

Wykres przedstawia proporcje interakcji pochodz¹cych z ka¿dej grup, w zale¿noœci od stacji. Wiêkszoœæ stacji zachowuje siê bardzo podobnie. Mo¿na jednak zauwa¿yæ dwie charaktarystyczne skupiska:

- grupy w których liczba krótkich interakcji przekracza ponad 50% wszystkich 
- grupy w których liczba krótkich interakcji jest znikoma w stosunku do ca³oœci 

Z powodu sporej iloœci stacji trudno jest odczytaæ konkretne nazwy. W zwi¹zku z tym podzielimy je na 4 grupy, zgodnie z podzia³em tematycznym CNK.

```{r echo= FALSE, cache=FALSE, message=FALSE, warning=FALSE}
##
# Grupa JA

interakcje_ja <-sqldf('select * from interakcje where station in ("cnk02a","cnk02b","cnk03","cnk05","cnk06","cnk07","cnk09","cnk10","cnk11","cnk13","cnk16","cnk17","cnk19a","cnk20","cnk21","cnk66","cnk67")')


ggplot(data=interakcje_ja, aes(x=station, y=count, fill=cluster)) + geom_bar(position ="fill",stat="identity")+theme(axis.text.x=element_text(angle=60)) + labs(x="stacje", y="Proporcje interakcji u¿ytkowników")+scale_fill_discrete(name="JA")

```

Widzimy, ¿e na stacjach: cnk02a, cnk02b - Mózg podczas pracy oraz cnk09 - Sztuka i emocje przewa¿a grupa odwiedzaj¹cych charakteryzuj¹ca siê ma³¹ iloœci¹ interakcji. W przeciwieñstwie do stacji cnk17 - Otwartoœæ na doœwiadczenie, gdzie ponad po³owa interakcji pochodzi od zwiedzaj¹cych wykonuj¹cych du¿o czynnoœci.
 

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
## Grupa JA-MY-ONI

#wybor stacji
interakcje_ja_my_oni <-sqldf('select * from interakcje where station in ("cnk100","cnk12","cnk32","cnk39","cnk40","cnk42a","cnk43","cnk44","cnk45","cnk49","cnk54","cnk55","cnk56","cnk57","cnk58b","cnk59","cnk60","cnk61","cnk62","cnk69","cnk71", "cnk72","cnk73","cnk79") ')


#wizualizacja
ggplot(data=interakcje_ja_my_oni, aes(x=station, y=count, fill=cluster)) + geom_bar(position ="fill",stat="identity")+theme(axis.text.x=element_text(angle=60)) + labs(x="stacje", y="Proporcje interakcji u¿ytkowników") + scale_fill_discrete(name="JA-MY-ONI")



```

W tej grupie widzimy spor¹ ró¿norodnoœæ. Wystêpuj¹ stacje, których krótkie interakcje s¹ ma³o znacz¹ce. Nale¿¹ do nich cnk40 - ¯yæ i prze¿yæ w grupie, cnk56 - Kamera - Akcja oraz cnk62 - Piêkny przeciêtny. Ponadto dla stacji cnk12 - Sztuczny czy szczery, cnk56 - Kamera - Akcja, cnk57 - Jêzyk Gazet najwiêcej jest odwiedzin z grupy o ma³ej liczbie interackji. Warto równie¿ zwróciæ uwagê na fakt, ¿e dla stacji cnk71 - Utopia przewa¿aj¹ odwiedzaj¹cy z licznymi interakcjami.

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}

## JA -SWIAT

# wybor stacji
interakcje_ja_swiat <-sqldf('select * from interakcje where station in("cnk37","cnk38","cnk46a","cnk46b","cnk47","cnk48a","cnk75"  )')

#wizualizacja
ggplot(data=interakcje_ja_swiat, aes(x=station, y=count, fill=cluster)) + geom_bar(position ="fill",stat="identity")+theme(axis.text.x=element_text(angle=60)) + labs(x="stacje", y="Proporcje interakcji u¿ytkowników")+scale_fill_discrete(name="JA -ŒWIAT")

```

W grupie JA-ŒWIAT szczególn¹ stacj¹ jest cnk38 - Ile ziem. Ta stacja ma najmniej krótkich interakcji spoœród wszystkich stacji.

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
#GRUPA JA-TY

#wybor stacji 
interakcje_ja_ty <-sqldf('select * from interakcje where station in ("cnk18","cnk22","cnk23","cnk24","cnk25","cnk26","cnk29a","cnk78a")')

#wizualizacja
ggplot(data=interakcje_ja_ty, aes(x=station, y=count, fill=cluster)) + geom_bar(position ="fill",stat="identity")+theme(axis.text.x=element_text(angle=60)) + labs(x="stacje", y="Proporcje interakcji u¿ytkowników")+scale_fill_discrete(name="JA -TY")
```

Tutaj szczególn¹ stacj¹ jest stacja cnk78a - Gadka szmatka, na której przewa¿aj¹ odwiedziny z niewielk¹ liczb¹ interakcji.  


Spróbujemy teraz podzieliæ odwiedzaj¹cych na grupy w zale¿noœci od liczby odwiedzonych eksponatów i œredniego czasu spêdzonego na stacjach.

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}

# odwiedziny Odwiedziny eksponatow
# srczasodwiedzin - Sredni czas odwiedzajacego na eksponacie
## srczasodwiedzajacego  - Sredni czas na odwiedzajacego
srczasodwiedzajacego<-srczasodwiedzajacego[srczasodwiedzajacego$sredniczas<3600,]

KM_srczas_stacji<-kmeans(scale(srczasodwiedzajacego[,2:3]), 3)
odwiedzajacy_klastr = srczasodwiedzajacego
odwiedzajacy_klastr$cluster = KM_srczas_stacji$cluster

liczba_klastrow = sqldf('SELECT cluster, count(*) FROM odwiedzajacy_klastr GROUP BY cluster')

ggplot(srczasodwiedzajacego,aes(x=srczasodwiedzajacego$sredniczas, y=srczasodwiedzajacego$liczbastacji, color=as.character(KM_srczas_stacji$cluster))) + geom_point(shape=1) + scale_x_continuous(limits=c(0, 1000)) + scale_y_continuous(limits=c(1, 35), breaks=c(1:35)) + labs(x="Œredni czas spêdzony przy stacji w [s]", y="Liczba odwiedzonych stacji") + guides(color=guide_legend(title="Klastry")) +ggtitle('Podzia³ na grupy ze wzglêdu na liczbê odwiedzonych stacji')

liczba_klastrow

```

Do podzia³u wykorzystaliœmy klasteryzacjê z algorytmu kmeans. Utworzyliœmy 3 klastry. Wykres jest uciêty na poziomie 35 odwiedzin z racji kwesti wizualnych. Patrz¹c na wykres oraz statystyki zauwa¿amy:
- grupê w której znajduj¹ siê osoby odwiedzaj¹ce niewielk¹ liczbê eksponatów i spêdzaj¹ce na nich niewielk¹ iloœæ czasu 
- grupê, w której znajduj¹ siê osoby które spêdzi³y wiêcej czasu na poszczególnych eksponatach
- grupê przedstawiaj¹c¹ osoby które odwiedzi³y du¿¹ liczbê eksponatów


### Regu³y odwiedzin 
Odpowiemy na pytania:

- Czy istniej¹ eksponaty które wp³ywaj¹ na zwiêkszon¹ liczbê odwiedzin eksponatów s¹siednich ?
- Czy, oraz w jaki sposób, po³o¿enie stacji ma wp³yw na jej odwiedziny ?

W tym celu bêdziemy korzystaæ z regu³ asocjacyjnych.

```{r echo=FALSE, cache=FALSE, message=FALSE, warning=FALSE}
load("macierz.rda")

######WSZYSTKIE STACJE##########

# obróbka macierzy macierz

macierz2 <- macierz[,-1]
macierz2$liczbastacji <- rowSums(macierz2)
#ustalam liczbê odwiedzaj¹cych stacji przynajmniej 10

macierz2 <-macierz2[macierz2$liczbastacji>9,]

#wyrzucam kolumnê liczba stacji,która jest na ostatniej 60 pozycji

macierz2 <-macierz2[,-60]

# tworzê macierz T-F
reguly <-(macierz2 == 1)

#1) metoda apriori
reg<- apriori(reguly, parameter = list(support= .1, minlen =1, maxlen=3))
inspect(head(sort(reg, by ="support")))
# Otrzymujê bardzo niskie wyniki support. Czêœciowo spowodowane niskim supportem danych pojedyñczych.

#2)metoda eclat
reg2 <- eclat(reguly,parameter = list(support= .1, minlen =2, maxlen=3))
inspect(head(sort(reg2, by="support")))



plot(head(sort(reg2, by="support"),30), method="graph", control=list(cex=.7), main="Po³aczenia stacji")


```


Widzimy, ¿e zdecydowana wiêkszoœæ po³¹czeñ ma zwi¹zek ze stacj¹ cnk19a, która mia³a najwiêksz¹ liczbê odwiedzaj¹cych. Zaburza to obraz po³¹czeñ i utrudnia dostrze¿enie ciekawych zale¿noœci. W zwi¹zku z tym zobaczymy sytuacjê ponownie, z pominiêciem stacji cnk19a.

```{r echo=FALSE,  cache=FALSE, message=FALSE, warning=FALSE}
macierz_bez19a <-macierz2[,-15]
reguly2<- (macierz_bez19a== 1)

### przyjmuje support 0.1
reg_bez19a<- eclat(reguly2, parameter= list(support = .1, minlen=2, maxlen=4))

## ograniczam siê do 30 najlepszych
bez_cnk19a <-head(sort(reg_bez19a, by="support"),30)
inspect(head(bez_cnk19a))
## wizualizacja wyniku - poprawic tytul !
plot(bez_cnk19a, method="graph", control=list(cex=.7), main="Najczêstsze po³¹czenia dla wszystkich stacji")


#########Grupy 3 elementowe 
## tylko eclant, bo apriori nic nie mówi
reg3_bez19a <- eclat(reguly2, parameter= list(support = .10, minlen=3, maxlen=4))
bez_cnk19a_3el <-(sort(reg3_bez19a, by="support"))
inspect(head(bez_cnk19a_3el))
plot(head(bez_cnk19a,30), method="graph", control=list(cex=.7), main="Po³¹czenia 3 elementowe dla stacji")
#######################

```

Pomimo ma³ej wartoœci support mo¿na zauwa¿yæ zale¿noœæ wspó³odwiedzania eksponatów. Zachodzi ona dla stacji po³o¿onych bezpoœrednio przy wejœciu do CNK. Potwierdza to przewa¿aj¹ca liczba eksponatów grupy tematycznej JA. 
Oprócz tej grupy znajduje siê jeszcze stacja grupy tematycznej JA-MY-ONI. Jednak ta stacja znajdujê siê jako jedyna w otoczeniu stacji grupy JA.
Zatem kluczowym elemetem wspó³odwiedzania jest po³o¿enie przestrzenne.

Warto jeszcze zauwa¿yæ fakt, ¿e stacja cnk16 jest stacj¹ zachêcaj¹c¹ do odwiedzenia innych stacji. Osoby odwiedzaj¹ce tê stacjê chêtniej zagl¹daj¹ do stacji blisko przy niej po³o¿onych.

###Grupowanie stacji i odwiedzajacych
Celem tej czêœci jest wyodrêbnienie 
- grup stacji
- grup odwiedzaj¹cych 
W oparciu o macierz odwiedzin, która na pozycji i,j ma jedynkê je¿eli
i-ty goœæ zwiedzi³ j-ty eksponat (zero w przeciwnym przypadku).

```{r echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}

# macierz.Rda zawiera dane obciete do malego zbioru visitorow ze wzgledu na czasochlonnosc obliczen
load("macierz.Rda")
### Klastrowanie na stacjach 

### obrobka danych do liczenia odlegosci
macierz <- t(macierz)
# wyciecie pierwszego wiersza odpowiadajacego numerow visitorow
macierzbw<-macierz[-1,]

macierzbw <- as.data.frame(macierzbw)
macierzbw <- data.matrix(macierzbw)
#mac <- macierzbw - 1
#save(mac,file = "mac.Rda")
load("mac.Rda")



```

###Odleg³oœæ JACCARDA
Postanowiliœmy wykorzystaæ odleg³oœæ jaccarda poniewa¿ ma ona w naszej sytuacji naturaln¹ interpretacjê:
- jak du¿o jest goœci którzy zwiedzili obie wybrane stacje, w stosunku do liczby tych, którzy odwiedzili przynajmniej jedn¹.

Aby przedstawiæ sytuacjê wizualnie rzutujemy nasze wyniki na przestrzeñ dwu-wymiarow¹.
Poniewa¿ rzutowanie metryczne nie bylo zadowalajace (wartoœæ 'stess' > 0.2 dla funkcji sammon{MASS}) postanowilismy skorzystaæ z altenratynego podejscia nie-metrycznyego: isoMDS{MASS} ( 'stress" ~ 0.13).
Wykorzystanie metody PCA w naszym badaniu by³o wykluczone poniewa¿ stosowne
odleg³oœci nie by³y oparte na metryce euklidesowej.

  
Do klastrowania wykorzystaliœmy metodê pam aby u³atwic interpretacjê wyników. Dla k=4 dostajemy 3 du¿e klastry i jeden 2 elementowy. 

```{r  echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
### vegdist{vegan} metoda jaccard daje nam odleglosci dla zero jedynkowej macierzy, 
m_klaster <- vegdist(mac, method="jaccard")

### Komentarz: 
# Na koniec naszej analizy chcielibysmy zwizualizowac wyniki
# naszego grupowania. Dlatego rzutujemy na przestrzen dwu wymiarowa
# Poniewaz rzutowanie metryczne nie bylo zadowalajace postanowilismy
# porownac to podejscie z nie-metrycznym

newcoord <- isoMDS(m_klaster, trace = FALSE)

# Niestety wartosc stresu (po unormowaniu) wychodzi podobna jak dla
# skalowania metrycznego co pokazuj, ze metoda niemetryczna nie daje istotnej przewagi
#[1] 13.94085

### Komentarz:
# Do klastrowania wykorzystalismy metode pam aby ulatwic interpretacje wynikow 
# dla k=4 dostajemy 3 duze klastry i jeden 2 elementowy 

grupy <- pam(newcoord$points, k=4)
pierwsze <- grupy$clustering
stacje <- row.names(macierzbw)
polaczenia <- as.data.frame(stacje)
polaczenia_jaccard <-as.data.frame(stacje)
polaczenia$clustering <- as.factor(grupy$clustering)
polaczenia$newcoordx <- newcoord$points[,1]
polaczenia$newcoordy <- newcoord$points[,2]
{count(grupy$clustering)}

ggplot(polaczenia, aes(x=newcoordx, y=newcoordy,label=stacje, color=clustering))+geom_point()+ theme_bw() + geom_text_repel()
{grupy$medoids}


```

Niestety wybór rzutowania ogranicza mo¿liwoœæ interpretacji odleg³oœci pojawiaj¹cych siê na wykresach. Mo¿na jedynie stwierdziæ, ¿e odleg³oœci odczytywane z wykresu mo¿liwie najlepiej odpowiadaj¹ wyjœciowym.
Co ciekawe klaster po³o¿ony w lewym górnym rogu w zdecydowanej wiêkszoœci sk³ada siê z eksponatów znajduj¹cych siê tu¿ przy wejœciu co wiêcej klaster ten najmocniej spoœród wszystkich utrzymywa³ siê przy zmianie liczby klastrów. Jest to grupa eksponatów wyró¿niaj¹ca siê w³aœciwie na ka¿dym etapie badania.


Powy¿sz¹ analizê dla porównania przedstawiamy równie¿ dla 7 klastrów.

```{r  echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
grupy <- pam(newcoord$points, k=7)

stacje <- row.names(macierzbw)
polaczenia <- as.data.frame(stacje)
polaczenia_jaccard <-as.factor(grupy$clustering)
polaczenia$clustering <- as.factor(grupy$clustering)
polaczenia$newcoordx <- newcoord$points[,1]
polaczenia$newcoordy <- newcoord$points[,2]

#load("polaczenia.Rda")
#save(polaczenia,file = "polaczenia.Rda")

ggplot(polaczenia, aes(x=newcoordx, y=newcoordy,label=stacje, color=clustering))+geom_point()+ theme_bw() + geom_text_repel()
{grupy$medoids}
```






###Odleg³oœæ MANHATTAN
Interpretacja tej odleg³oœci dla dwóch stacji A,B to: 
-liczba goœci ktorzy odwiedzili dok³adnie jedn¹ stacje spoœród A i B.

```{r  echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}
#########################  poczatek: metoda manhattan  ###################################################
load("mac.Rda")
m_klaster <- dist(mac, method ="manhattan")

newcoord <- isoMDS(m_klaster, trace= FALSE)

# newcoord <- isoMDS(m_klaster)
#initial  value 29.115618 
#final  value 29.115613 
#converged

### Komentarz:
# Do klastrowania wykorzystalismy metode pam aby ulatwic interpretacje wynikow 
# dla k=4 dostajemy 3 wieksze klastry i jeden 2 elementowy

############skalowanie 
newcoord$points <- scale(newcoord$points)
grupy <- pam(newcoord$points, k=4)
drugie <- grupy$clustering
################
#(grupy$medoids)
stacje <- row.names(macierzbw)
polaczenia1 <- as.data.frame(stacje)
polaczenia_manhattan <-as.factor(grupy$clustering)
polaczenia$clustering <- as.factor(grupy$clustering)
polaczenia$newcoordx <- newcoord$points[,1]
polaczenia$newcoordy <- newcoord$points[,2]
{count(grupy$clustering)}
ggplot(polaczenia, aes(x=newcoordx, y=newcoordy,label=stacje, color=clustering))+geom_point()+ theme_bw() + geom_text_repel()


```

#### Klastrowanie na wizytorach 
Po przeprowadzeniu wstêpnych badañ uznaliœmy, ¿e nale¿y ograniczyæ analizê do odwiedzaj¹cych o stosunkow du¿ej liczbie obejrzanych stacji. Brak tej restrykcji prowadzi³ do sytuacji takich jak: goœæ A odwiedzi³ jedn¹ stacje, goœæ B dwadzieœcia, przeciecie = 1 , jednak A i B wci¹¿ trafiaj¹ do wspólnego klastra.
Za odpowiednie uznaliœmy wybranie górnego kwartyla, co w efekcie da³o
granice "co najmniej 10 odwiedzonych stacji".

Pokazujemy wyniki tylko dla:
Odleg³oœæ: Jaccard
Rzutowanie: isoMDS
Poniewa¿ stosowanie innych metod dawa³o bardzo podobne rezultaty.

```{r echo=FALSE, cache=FALSE, message=FALSE, warning=FALSE}
mak <- as.data.frame(macierz)
mak <- data.matrix(mak)
mak <- (mak - 1)
mak <- t(mak)
mak <- mak[,-1]
# Na poczatku klastrowalismy na wszystkich visitorach ale prowadzilo to do sytuacji typu:
# visitor A odwiedzil jedna stacje, visitor B dwadziescia, przeciecie = 1 ale A i B nadal 
# laduja we wspolnej grupie dlatego postanowilismy sie ograniczyc do visitorow o relatywnie 
# duzej liczbie odwiedzonych sciezek. Na podstawie ponizszego przyjelismy granice 10:


#quantile(rowSums(mak))
#0%  25%  50%  75% 100% 
#1    3    6   10   48
extractor <- rowSums(mak)
extractor <- extractor >=10
mak <- mak[extractor,]
# w rezultacie otrzymalismy 10194 visitorow 
maczek <- mak

maczek <- maczek[1:500,]


## Komentarz
#Na koniec naszej analizy chcielibysmy zwizualizwoac wyniki naszego #grupowania. Dlatego rzutujemy na przestrzen dwu wymiarowa
# (dopisac info na temat rzutowania)

maczek_klaster <- vegdist(maczek, method="jaccard")
### rzutowanie na przestrzen 2-wymiarowa
newcoord <- isoMDS(maczek_klaster, trace=FALSE)


### klastrowanie k=6
grupy <- pam(newcoord$points, k=6)
visitors <- row.names(maczek)
polaczenia <- as.data.frame(visitors)
polaczenia$clustering <- as.factor(grupy$clustering)
polaczenia$newcoordx <- newcoord$points[,1]
polaczenia$newcoordy <- newcoord$points[,2]


polaczenia2 <- polaczenia
ggplot(polaczenia2, aes(x=newcoordx, y=newcoordy,label=visitors, color=clustering))+geom_point()+ theme_bw()
#{grupy$medoids}



```


Widzimy ¿e otrzymaliœmy istotnie mniej interesuj¹ce grupowanie ni¿ dla stacji.
Okazujê siê, ¿e odwiedzaj¹cy s¹ roz³o¿eniu w przestrzeni bardzo równomiernie i 
niestety nie mo¿na wyodrebniæ ciekawych klastrów.


### Porównanie klastrów i stref
Zauwa¿my, ¿e zastosowane klastrowanie na macierzy odwiedzin prowadzi 
(przy ka¿dej z metod liczenia odleg³oœci) do nastêpuj¹cej charakteryzacji: 
jeœli mamy wybran¹ stacjê CNK{X} przypisan¹ do klastra K(X) to osoby 
odwiedzaj¹ce stacje X przewa¿nie odwiedzaj¹  stacje z klastra K(X).
Zaciekawi³o nas, czy otrzymany w ten sposób podzia³ jest podobny do klasyfikacji 
tematycznej. Porównamy równie¿ rezultaty osiêgniête przy korzystaniu z odleg³oœci
"jaccard" oraz manhattan". 
Do zbadania podobieñstwa klastrów u¿yliœmy zmodyfikowanego indeksu Randa który
ma wartoœæ oczekiwan¹ jeden je¿eli grupowania s¹ identyczne a zero gdy 
s¹ niezale¿ne.

```{r echo=FALSE, cache=FALSE, message=FALSE, warning=FALSE}
#tematycznie <- read.xlsx(1, file = "nazwy.xlsx")
#tematycznie <- tematycznie[,-6]
#tematycznie <- tematycznie[,-(3:4)]
#tematycznie <- tematycznie[-1,]
#tematycznie <- tematycznie[-(91:95),]
#names(tematycznie) <- c("Numer", "Nazwa stacji", "Strefa")
#row.names(tematycznie) <- c(1:nrow(tematycznie))
#save(tematycznie, file = "tematycznie.Rda")
#rm(tematycznie)


load("tematycznie.Rda")
load("macierz.Rda")
nasze <- colnames(macierz)[-1]
tematycznie[,1] <- as.character(tematycznie[,1])
tematycznie[,1] <- gsub(pattern = "CNK", replacement = "cnk",tematycznie[,1])
tematycznie[,1] <- gsub(pattern = "A", replacement = "a",tematycznie[,1])
tematycznie[,1] <- gsub(pattern = "B", replacement = "b",tematycznie[,1])
tematycznie[,1] <- gsub(pattern = "C", replacement = "c",tematycznie[,1])
tematycznie[,1] <- gsub(pattern = "D", replacement = "d",tematycznie[,1])
tematycznie[,1] <- gsub(pattern = "E", replacement = "e",tematycznie[,1])
tematycznie <- tematycznie[tematycznie[,1] %in% nasze,]

#Sortowanie pakietu tematycznie wedlug numeru stacji
pom <- as.data.frame(pierwsze)
target <- row.names(pom)
target <- target[target %in% tematycznie[,1]]
rm(pom)
tematycznie <- tematycznie[match(target,tematycznie$Numer),]

```


Zmodyfikowany indeks Randa dla 4-elementowych klastrów opartych na 
odleg³oœci "jaccard" i "manhattan":

```{r echo=FALSE,  cache=FALSE, message=FALSE, warning=FALSE}

{adjustedRandIndex(pierwsze, drugie)}

pierwsze <- as.data.frame(pierwsze)
drugie <- as.data.frame(drugie)
pierwsze <- pierwsze[row.names(pierwsze) %in% target,]
drugie <- drugie[row.names(drugie) %in% target,]

```

Zmodyfikowany indeks Randa dla 4-elementowych klastrów opartych na:
(a) odleg³oœci "jaccard" (b) strefach tematycznych:


```{r echo=FALSE, cache=FALSE, message=FALSE, warning=FALSE}
{adjustedRandIndex(tematycznie$Strefa, pierwsze)}
```

Zmodyfikowany indeks Randa dla 4-elementowych klastrów opartych na:
(a) odleg³oœci "manhattan" (b) strefach tematycznych:

```{r echo=FALSE, cache=FALSE, message=FALSE, warning=FALSE}
{adjustedRandIndex(tematycznie$Strefa, drugie)}

```

Pojawia siê interesuj¹ca w³aœciwoœæ: otrzymaliœmy wiêksze podobieñstwa na polu "klastrowanie oparte na odwiedzinach" versus "klastrowanie oparte o strefy" ni¿ dla dwóch grupowañ z wykorystaniem tej samej macierzy odwiedzin i odmienn¹ odleg³oœci¹.

Zwi¹zek miêdzy klastrami na macierzy odwiedzin oraz podzia³em tematycznym 
mo¿na te¿ ³adnie zilustrowaæ za pomoc¹ map ciep³a: 

```{r  echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}

##### mapa ciep³a jaccard######
polaczenia1<-as.data.frame(stacje)
polaczenia1$clustering <- polaczenia_jaccard

nowa_ja<-sqldf('select * from polaczenia1 where stacje in ("cnk02a","cnk02b","cnk03","cnk05","cnk06","cnk07","cnk09","cnk10","cnk11","cnk13","cnk16","cnk17","cnk19a","cnk20","cnk21","cnk66","cnk67") ')

nowa_ja_swiat <-sqldf('select * from polaczenia1 where stacje in("cnk37","cnk38","cnk46a","cnk46b","cnk47","cnk48a","cnk75"  )')

nowa_ja_my_oni <-sqldf('select * from polaczenia1 where stacje in ("cnk100","cnk12","cnk32","cnk39","cnk40","cnk42a","cnk43","cnk44","cnk45","cnk49","cnk54","cnk55","cnk56","cnk57","cnk58b","cnk59","cnk60","cnk61","cnk62","cnk69","cnk71", "cnk72","cnk73","cnk79") ')

nowa_ja_ty <-sqldf('select * from polaczenia1 where stacje in ("cnk18","cnk22","cnk23","cnk24","cnk25","cnk26","cnk29a","cnk78a")')

tbl<-1:16
dim(tbl)=c(4,4)
tbl<- as.data.frame(tbl)
dimnames(tbl)=list(c("JA", "JA - MY - ONI", "JA - ŒWIAT", "JA - TY"),c("Cluster1", "Cluster2", "Cluster3","Cluster4"))

tbl[1,1]<-sqldf('select Count(*) FROM nowa_ja WHERE clustering==1')
tbl[1,2]<-sqldf('select Count(*) FROM nowa_ja WHERE clustering==2')
tbl[1,3]<-sqldf('select Count(*) FROM nowa_ja WHERE clustering==3')
tbl[1,4]<-sqldf('select Count(*) FROM nowa_ja WHERE clustering==4')

tbl[2,1]<-sqldf('select Count(*) FROM nowa_ja_my_oni WHERE clustering==1')
tbl[2,2]<-sqldf('select Count(*) FROM nowa_ja_my_oni WHERE clustering==2')
tbl[2,3]<-sqldf('select Count(*) FROM nowa_ja_my_oni WHERE clustering==3')
tbl[2,4]<-sqldf('select Count(*) FROM nowa_ja_my_oni WHERE clustering==4')

tbl[3,1]<-sqldf('select Count(*) FROM nowa_ja_swiat WHERE clustering==1')
tbl[3,2]<-sqldf('select Count(*) FROM nowa_ja_swiat WHERE clustering==2')
tbl[3,3]<-sqldf('select Count(*) FROM nowa_ja_swiat WHERE clustering==3')
tbl[3,4]<-sqldf('select Count(*) FROM nowa_ja_swiat WHERE clustering==4')

tbl[4,1]<-sqldf('select Count(*) FROM nowa_ja_ty WHERE clustering==1')
tbl[4,2]<-sqldf('select Count(*) FROM nowa_ja_ty WHERE clustering==2')
tbl[4,3]<-sqldf('select Count(*) FROM nowa_ja_ty WHERE clustering==3')
tbl[4,4]<-sqldf('select Count(*) FROM nowa_ja_ty WHERE clustering==4')



pheatmap(tbl, border="blue",
         color = brewer.pal(9,"Blues"),
         main="Licznoœæ eksponatów z stref tematycznych w klastrach (JACCARD)")


```

Widzimy mocny zwi¹zek miêdzy stref¹ "JA" i pierwszym klastrem.



```{r  echo = FALSE, cache=FALSE, message=FALSE, warning=FALSE}

################# mapa ciep³a manhattan ######

polaczenia1<-as.data.frame(stacje)
polaczenia1$clustering <- polaczenia_manhattan

nowa_ja<-sqldf('select * from polaczenia1 where stacje in ("cnk02a","cnk02b","cnk03","cnk05","cnk06","cnk07","cnk09","cnk10","cnk11","cnk13","cnk16","cnk17","cnk19a","cnk20","cnk21","cnk66","cnk67") ')

nowa_ja_swiat <-sqldf('select * from polaczenia1 where stacje in("cnk37","cnk38","cnk46a","cnk46b","cnk47","cnk48a","cnk75"  )')

nowa_ja_my_oni <-sqldf('select * from polaczenia1 where stacje in ("cnk100","cnk12","cnk32","cnk39","cnk40","cnk42a","cnk43","cnk44","cnk45","cnk49","cnk54","cnk55","cnk56","cnk57","cnk58b","cnk59","cnk60","cnk61","cnk62","cnk69","cnk71", "cnk72","cnk73","cnk79") ')

nowa_ja_ty <-sqldf('select * from polaczenia1 where stacje in ("cnk18","cnk22","cnk23","cnk24","cnk25","cnk26","cnk29a","cnk78a")')


tbl<-1:16
dim(tbl)=c(4,4)
tbl<- as.data.frame(tbl)
dimnames(tbl)=list(c("JA", "JA - MY - ONI", "JA - ŒWIAT", "JA - TY"),c("Cluster1", "Cluster2", "Cluster3","Cluster4"))

tbl[1,1]<-sqldf('select Count(*) FROM nowa_ja WHERE clustering==1')
tbl[1,2]<-sqldf('select Count(*) FROM nowa_ja WHERE clustering==2')
tbl[1,3]<-sqldf('select Count(*) FROM nowa_ja WHERE clustering==3')
tbl[1,4]<-sqldf('select Count(*) FROM nowa_ja WHERE clustering==4')

tbl[2,1]<-sqldf('select Count(*) FROM nowa_ja_my_oni WHERE clustering==1')
tbl[2,2]<-sqldf('select Count(*) FROM nowa_ja_my_oni WHERE clustering==2')
tbl[2,3]<-sqldf('select Count(*) FROM nowa_ja_my_oni WHERE clustering==3')
tbl[2,4]<-sqldf('select Count(*) FROM nowa_ja_my_oni WHERE clustering==4')

tbl[3,1]<-sqldf('select Count(*) FROM nowa_ja_swiat WHERE clustering==1')
tbl[3,2]<-sqldf('select Count(*) FROM nowa_ja_swiat WHERE clustering==2')
tbl[3,3]<-sqldf('select Count(*) FROM nowa_ja_swiat WHERE clustering==3')
tbl[3,4]<-sqldf('select Count(*) FROM nowa_ja_swiat WHERE clustering==4')

tbl[4,1]<-sqldf('select Count(*) FROM nowa_ja_ty WHERE clustering==1')
tbl[4,2]<-sqldf('select Count(*) FROM nowa_ja_ty WHERE clustering==2')
tbl[4,3]<-sqldf('select Count(*) FROM nowa_ja_ty WHERE clustering==3')
tbl[4,4]<-sqldf('select Count(*) FROM nowa_ja_ty WHERE clustering==4')

(tbl)

pheatmap(tbl, border="blue",
         color = brewer.pal(9,"Blues"),
         main="Licznoœæ eksponatów z stref tematycznych w klastrach (MANHATTAN)")
```

Widzimy mocny zwi¹zek miêdzy stref¹ "JA-MY-ONI" i trzecim klastrem.


#Podsumowanie 

Analiza prowadzi do nastêpuj¹cych wniosków:

### Ogólne:
- Rozk³ad czasu spêdzonego przy maszynie wydaje siê byæ zbli¿ony do rozk³adu gamma. 
  Widaæ jednak, ¿e w okolicach 100 sekund nastêpuje znaczny skok liczby odwiedzaj¹cych.
- Zauwa¿amy, ¿e najbardziej odwiedzan¹ stacj¹ by³o Wejœcie do sali strachów - cnk19a 
  oraz Wyjœcie z sali strachów - cnk19b. Innymi czêsto odwiedzanymi eksponatami s¹: 
  Pow¹chaj mnie - cnk16, Mózg podczas pracy - cnk02 oraz Kim jesteœ - cnk18.
- Mo¿na zauwa¿yæ, ¿e zdecydowanie najwiêcej odwiedzin by³o w grupie JA. 

### Podzia³ odwiedzaj¹cych:
Gdy dokonamy podzia³u odwiedzaj¹cych na trzy grupy w zale¿noœci od:
 - liczby wejœæ na danej stacji przez odwiedzaj¹cego
 - ³¹cznej liczba czynnoœci na wszystkich eksponatach
 - œredniego czas spêdzony na wszystkich odwiedzonych stacjach 
 - liczby odwiedzonych stacji  
 
to otrzymujemy:

 a)Czynnikiem rozró¿niaj¹cym odwiedzaj¹cych jest g³ównie liczba interakcji.

 b)Grupê osób charakteryzuj¹cych siê du¿¹ liczb¹ interakcji i krótkim czasem spêdznym na eskponacie;
   Grupê poœredni¹;
   Grupê osób charakteryzuj¹cych siê d³ugim czasem interakcji i ma³¹ liczba odwiedzin.

 c)Stosunkowo niewielka liczba odwiedzaj¹cych plasuje siê powy¿ej œredniego czasu odwiedzin równego 250 sekund.

 d)Udzia³ ka¿dej  grupy goœci wœród odwiedzaj¹cych poszczególn¹ stacje ró¿ni siê istotnie w zale¿noœci od stacji.
   Co wiêcej mo¿na zauwa¿yæ zale¿noœæ tej proporcji od podzia³u na kategorie: JA, JA-MY-ONI, JA-SWIAT, JA-TY

### Regu³y przejœcia:
- Kluczowym elemetem wspó³odwiedzania jest po³o¿enie przestrzenne.
- CNK16 - "Pow¹chaj mnie" jest stacj¹ zachêcaj¹c¹ do odwiedzenia innych eksponatów


### Podzia³ stacji:
- Istniej¹ charakterystyczne grupy stacji ze wzglêdu na wspó³wystêpowanie odwiedzin.
Du¿o trudniej jest jednak dostrzec analogiczn¹ zale¿noœæ dla goœci.
Wyniki poœrednie otrzymane w trakcie badania wskazuj¹, ¿e odpowiedzialne
za t¹ ró¿nice s¹ osoby które w niewielkim stopniu korzystaj¹ z mo¿liwoœci
oferowanych przez CNK. Potwierdzi³ siê znany fakt, ¿e otrzymane klastrowanie istotnie zale¿y od wyboru odleg³oœci.
- Mo¿na zauwa¿yæ istotne podobieñstwo klasyfikacji stacji w oparciu o 
 "wspólne odwiedzanie" z podzia³em na strefy. Wskazuje na to zmodyfikowany 
 indeks Randa (0.4320327 dla odleg³oœci liczonej metod¹ "jaccard", 0.3107382
 dla odleg³oœci liczonej metod¹ "manhattan"). Podobieñstwo to jest wiêksze
 ni¿ gdy rozpatrzymy t¹ sam¹ bazow¹ macierz odwiedzin i dwie powy¿sze odleg³oœci
 (zmodyfikowany Rand 0.2502076).

